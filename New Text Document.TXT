РОУТИНГ - это логика, которая позволяет пользователю передвигаться по сайту. Она может быть нативная, то-есть, когда мы в html документ добавляем ссылку ан внутреннюю страницу. В результате, при клике, пользователь получает к ней доступ. А также роутинг может быть эмулирован, если мы говорим о SPA. В этом случае, вместо перехода на новую страницу, будет выполнен просто рендеринг нового компонента.






Порядок выполнения проекта.

1) Подключили модуль http для создания сервера.
2) Создали сервер и начали его слушать.
3) Установили модуль файловой системы.
4) Сделали так, чтобы при запросе на главную страницу, мы проверяли нету ли ошибки в запросе и если её нету, то отправляли содержимое главной страницы в браузер и передавали ему контроль.
5) Подключили модуль path для формирования полного пути к файлам в виде строки. Также этот модуль отлично справляется с задачей, когда слеши в других браузерах обернуты не в ту сторону. `const createPath = (page) => path.resolve(__dirname, 'views', `${page}.html`);`.
6) Убрали проверку на путь, которая была раньше, через if и сделали switch case, для того, чтобы можно было перейти уже на любую страницу и сервер возвращал ответ.
7) Расширяем статус кода, для того, чтобы сделать нашу логику более универсальной.

    СТАТУСЫ кода {
        Делятся на 5 больших групп
        Range           Use

        1**             Information
        2**             Success
        3**             Redirection
        4**             Client errors
        5**             Server errors
    }
8) Создаем redirect.
9) Создаем множественные пути для одной веб страницы с помощью обычного switch case. Тут работает не redirect, а обработка нескольких путей и возврат одного html документа.
10) Рассматриваем пакетный менеджер. инициализируем npm init, для того, чтобы можно было подключать другие пакеты к проекту. Пакетом может являться какая нибудь библиотека или готовый функционал, который можно использовать в нашем проекте.
11) Установили nodemon для того, чтобы не нужно было каждый раз перезагружать сервер. Сервер автоматически обновляется при обновлении частей кода.
12) Базовый команды для работы с npm {

    Command                             Description

    npm init                            npm initialization *
    npm install                         Installing all project dependencies *
    npm install -g <package>            Install package globally
    npm install --save-dev <package>    Install with develop dependency *
    npm install <package>@1.0.0         Install package with specific version
    npm install <package>@latest        Install latest version of package *
    npm unistall <package>              Unistall one spesific module

                    (*) - чаще всего используются.
}

13) Устанавливаем express и ejs, которые понадобятся в будущем. Express - это nodeJs framework для более элегантной работы с запросами и ответами. Поможет сокротить код написания соединения сервера и браузера. EJS - это шаблоизатор для введения динамических данных на наш сайт.
Express - это достаточно популярный и минималистичный веб фреймворк, который написан на джава скрипт. Он простой и лаконичный, а также предоставляет набор функций для мобильных и веб приложений. С помощью него, мы будем создавать простой и гибкий роутинг. Добавления мидлваров на наш сервер, работы с API, а также для удобной интеграции с ejs шаблонизатором.
14) Варианты запросов, с которыми мы будем работать {

    HTTP Method                     Description

    GET                             Getting data
    POST                            Sending new data
    DELETE                          Delete existing data
    PUT                             Update existing data
Они соответсвуют стеку крат операций.
}
14.1) Мы создали новый файл, для того, чтобы продемонстрировать работу с помощтю express.
15) Для того, чтобы отправить данные с сервера в браузер, мы используем метод app.get.
16) В экспресс не нужно отправлять content-type, он сам автоматически определяет тип данных и сетает нужный заголовок. setHeader - больше не нужен.
17) Импортируем снова модуль path и копируем функцию createPath.
18) Заменяем метод send на метод sendFile уже для того, чтобы мы могли отправлять файлы. Вставляем внутрь функцию createPath с именем страницы.
19) Тоже самое делаем для контактов.
20) Для страницы с ошибкой мы будем использовать не метод get, а use. В нём мы не указываем путь, так как не знаем, куда пользователь будет хотеть зайти. Мы создаем middleware, который будет перехватывать запросы по не существующим путям и рендерить ошибку.
21) Дополнительно в этот метод, нам нужно добавить статус код. Можем сделать как в nodeJs, а можем воспользоватся синтаксисом из цепочки методов и методом status().
22) В Экспресс порядок роутов имеет значение, поэтому, например, роут с редиректом, не может идти после нашего миддлвара, у которого заложена логика перехвата несуществующих путей.
23) С экспресс не нужно вручную обрабатывать кейсы кодировок и чтение файлов, всё это автоматизировано под капотом. Легче добавлять ППО или мидлвары.
24) Урок 12. Мы рассмотрим использование ejs шаблонизатора, для того, чтобы создать пользовательский интерфес, а также превратим статичные html страницы в динамичные, которые будут получать данные от сервера и рендерить их.
25) Делаем роуты также как и раньше, используя метод get, только на страницу с post, мы добавляем id, так как будем запрашивать один конкретный пост.
26) Подключаем в наш проект ранее установленный ejs. Делается это в 3 шага. В начале, мы устанавливаем для нашего приложения ejs, в качестве viewEngine.
27) Далее немного обновим функцию createPath. Все страницы у нас находятся в папке views, но помимо этой папки, мы создаем папку ejs-views, которая содержит копии тех же файлов с той лиж разницой, что расширение не html, а ejs. Поэтому в функции createPath, мы должны обновить данные для правильного определения пути.
28) Заключительным шагом будет изменить наш метод sendFile на render. В каждом из записаных роутов, после данных операций, наше приложение начнет использовать ejs в качетсве шаблонизатора для страниц, вместо статики.
29) Какие теперь возможности у нас есть. Для начала мы можем воспользоваться так называемым partial template (отдельный шаблон), а именно вынести одинаковую часть кода со всех файлов в отдельный файл, (инкапсулируем повторяющиеся части).
30) Создаем папку partials с файлом nav.ejs, куда помещаем навигацию скопированную с любой станицы и удаляем часть кода с навигацией со всех страниц, а вместо этого куска кода, вставляем строку, написанную с помощью синтаксиса ejs. (<%- include('./partial/nav.ejs')%>) - которая содержит метод?? include и путь к файлу с навигацией. В целом это очень стандартная функциональность характерна для любого шаблонизатора, отличие только в синтаксисе.
31) Теперь давайте рассмотрим передачу данных, шаблоны страниц. Использую синтаксис ejs <%= some value%>, но добавив равно, мы обращаемся к пространству имен шаблонизатора. В коде html, мы можем описать любой js код. Это может быть и функция и любая другая логика.
32) Напрямую работать с ejs, браузер не может, так как в качестве разметки он принимает html. Но ejs способен работать с динамически подставляемыми данными, поэтому на нашем сервере мы используем middleware viewEngine, в котором определяем тип шаблонизатора. viewEngine пропускает через себя ejs, а по итогу возвращает статичный html, который отправляется в браузер.
33) Основная задача заключается в том, что формировать на сервере нужные данные и отправлять их в шаблон. Начнем с того, что будем формировать список социальных сетей на сервере и возвращать в шаблон. Теперь в метод render передаём эти данные.
По сути всё готово, теперь только нужно в шалоне их отрендерить. Для этого вступает в силу специфический синтаксис шаблонизатора.


{

 <% if(contacts.length){ %>
                <% contacts.forEach(({link, name})=>{ %>
                    <li>
                        <a href='<%=link %>'"><%= name %></a>
            </li>
            <% }); %>
            <% } %>

}

34) Создали переменную title в каждом роуте и тем же методом дополнили данные в каждом из файлов, чтобы тайтлы на страницы динамически изменялись.
35) Далее рассмотрим работу с middleware или как ещё называют промежуточное ПО. В контексте nodeJs, это функция, которая исполняется между получением запроса сервером и отправкой им ответа браузеру. 
36) Для начала рассмотрим варинат логирующего middleware. Так как middleware промежуточный функционал, он не может сам закончится, нужно передать контроль серверу для дальнейшей работы с помощью next();. Но серве не знает что ему делать дальше, поэтому это нужно прописать. Давайте сделаем ещё один middleware, который не будет делать ничего существенного, а будет просто выводить сообщение в консоль. 
{
    app.use((req, res, next) => {
    console.log(`path: ${req.path}`);
    console.log(`mathod: ${req.method}`);
    next();
});
app.use((req, res, next) => {
    console.log(`just for test`);
    next();
});

}
Мы увидили, что сработали и тот и тот middleware, что показывает нам, что мы можем добавлять столько middleware, сколько нужно и передавать контроль каждому по цепочке. 
Также ещё нужно учитывать порядок записи. Если мы хотим, чтобы обработчики срабатывали между запросом и ответом, нам нужно их вставлять в самом начале после создания сервера и прослушивания порта. Или если сказать по другому, до создания роута с ответом. Это потому, что у нас в каждом роуте есть метод, res.render, которая отправляет ответ обратно в браузер и наша промежуточная функциональность просто не успаевает отработать. Удаляем второй middleware, который для был для примера "Just for test".
37) Вынесли стили в отдельный файл и делаем из каждого шаблона ссылку на стили, но работать ничего не будет, так как когда мы добавляем статичные файлы в наш проект, по типу стилей или картинок, то мы не можем получить к ним доступ. Всё дело в том, что если бы браузер смог работать с такими файлами, то это означало бы, что пользователь может получить доступ к любым файлам на сервере. Поэтому nodeJs, по умолчанию защищает все хранящиеся данные. Поэтому для того, чтобы браузер имел доступ к статичным данным, нам нужно это разрешить. 
Это делается как раз таки с помощью middleware, в катором мы определяем файлы и папки, к которым у браузера есть доступ. 
38) Используем стандартную конструкцию app.use внутрь которой передаём express.static. Данный метод поможет добавить передаваемую папку в исключения.
39) Подключаем нормальный loger с помощью npm install morgan и импортируем его в наш модуль. Затем заменяем наш самописный консольный логер на нормальный. Мы будем видеть метод, статус, длинну контента и время ответа в милисекундах.
(app.use(morgan(':method :url :status :res[content-length] - :response-time ms'));) - этот миддлевар вместо нашего.
40) Далее мы рассмотрим обработку POST запроса на стороне сервера, но сначала ещё немного поработаем с нашими шаблонами.
Так как у нас head во всех файлах одинаковый, мы выносим его в отдельный файл head.ejs и заменяем на include во всех файлах. Далее нам нужно окончательно отказаться от статичного контента на наших страницах, а именно posts - страница, которая содержит логику всех получаемых постов, и post - страница для отдельного поста. 
Для начала нужно перенести моковые данные в файл сервера. 
{
    const post = {
        id: '1',
        text: 'Lorem Lorem Lorem Lorem Lorem Lorem Lorem Lorem Lorem Lorem',
        title: 'post-title',
        date: '01.05.1997',
        author: 'Svoikin Rostyslav',
    };
}
Добавляем в обьект, который мы передаем в метод render, вторым аргументов наш обьект post и заменяем все нужные строки на странице post, используя синтаксис ejs.
Далее нам нужно сделать тоже самое на странице со всеми постами, для этого достаточно в файле server создать массив с примером одного обьекта (одного поста), так как это массив новостей.
{
    const posts = [{
        id: '1',
        text: 'Lorem Lorem Lorem Lorem Lorem Lorem Lorem Lorem Lorem Lorem',
        title: 'post-title',
        date: '01.05.1997',
        author: 'Svoikin Rostyslav',
    }];
}

Далее переходив в файо posts и заменяем нужные данные, чтобы перейти со статики на динамику.
41) Дальше рассмотрим отправку данных на сервер с помощью метода post. Для начала переходим на страницу add-post и добавляем нужные атрибуты в тег form. Указываем method POST и action с адресом add-post. Но можно было атрибут action и опустить, так как по умолчанию, если он не указан, страница будет ссылаться сама на себя. Action содержит роут, который и будет обрабатывать получаемые с формы данные.
42) Первое что нам нужно сделать, это добавить middleware для парсинга входящего запроса. Раньше для этих целей применялся внешний модуль, который назыался bodyParser, но на данный момент он считается устаревшим, а его логика была благополучно интегрирована в экспресс. Таким образом, у нас появился метод URL encoded. Внутрь он принимает аргументы, в нашем случае мы укажем extends false, так как расширенный парсинг нам не нужен.
43) После того, как миддлвар подключен в файл сервера, нам нужно создать роут, который будет обрабатывать получаемые данные. Делается он аналогичко как и метод get, только используется метод post. Для начала просто используем уже знакомый метод send, чтобы проверить как всё работает.
44) Поскольку у нас есть шаблон post, который рендерить одну новость, почему бы нам не воспользоватся им и не отобразить получаемую с формы информацию. Но у нас будет ожидаемо ошибка, так как шаблон использует передаваемую дату, а даты в нашем передаваемом ответе нет. Есть 2 варианта. 1) Это использование дефолтного атрибута для поля. По сути это тоже дефолтное значение что и в JS. <%= date || 'NO DATE'%>. 2) Второй вариант, это рассширить post данными, напрямую на сервере. Добавляем айди, куда присваиваем new Date. (id: new Date();). Также добавим свойство date, куда присвоем new Date и используем метод toLocalDateString, чтобы дата отображалась в нормальном формате. Мы научились обрабатывать post запросы, единственная проблема, это то, что мы не храним данные.

//-----------------------Интеграция БД в проект----------------------------------
45) Для начала регестрируемся на сайте mongoDB, нажимаем создать кластер и во вкладке с тарифами выбираем тот, который бесплатный. 
После того как кластер создан, нужно внутри него добавить новую коллекцию. После чего добавляем пользователя, с определенным вариантом доступа, в зависимости от нужды. 
46) Далее мы можем приступать к интеграции базы в наше приложение.
47) Для начала нам нужно установить пакет mongoose, так как напрямую обращаться к базе мы не можем. 
48) После установки, импортируем его в наш сервер.
49) Переходим обратно на сайт и во вкладке database нажимаем connect. Так как мы будем подсоединяться через приложение, то выбираем обцию через приложение.
50) Потом переходив в наше приложение и создаем константу db, куда и присвоим скопированную строку подключения.
(Нужно иметь ввиду, что это не полностью сконфигурированная строка)
51) Нужно заменить часть строки password на тот пароль, который мы создали и myFristDataBase на то имя базы, которое мы создали.
52) После этого мы уже можем устанавливать подключение.
53) Для этого мы используем mongoose который импортировали рание, а в частности метод connect, внутрь которого передаём константу db.
Поскольку это тоже асинхронная операция, мы можем использовать метод then и catch. Внутри then выведим в консоль строку, что мы успешно подключились к БД. А в catch ошибку, если она будет, а она будет. Нужно добавить атрибуты 
{
    .connect(db, { useNewUrlParser: true, useUnifiedTopology: true })
}
54) После чего, нужно установить доступ на сайте откуда угодно, а не только с вашего компьютера.(в данном случае)
55) Далее переходим к созданию схем. Схема это своего рода обьект, который будет описывать структуру данных.
56) В главной папке создаем ещё одну папку под названием models и внутри создаем файл post.js
57) Внутри этого файла мы опишим схему нашего поста.
Для начала импортирум модуль mongoose и вытагиваем из него конструктор Schema. Теперь создаем константу postSchema и присваиваем в неё вызов конструктора, внутри которого описываем обьект. Если мы перейдем в файл сервера и посмотрим структуру нашего поста, то мы увидим, что он содержит такие поля как id, text, title etc... Эти поля нам и нужно описать. Свойство id мы не описываем, так как мы его не передаём. Оно будет создаваться автомаически для каждой добавляемой сущности.
Для начала описываем text. Его тип, это строка и recuired устанавливаем как true. Теперь не трудно догадаться, что текст это обязательная строка и если её не передать, будет ошибка. Копируем эту конструкцию для свойств title и author. Это тоже строки и тоже обязательные поля.
58) Вторым аргументом в конструктор, можно передавать конфигурируемый обьект. Мы им воспользуемся для того, чтобы передать свойство timestamps. Это как раз таки та дата, коорая будет присваиваться к любому созданому посту. 

СХЕМА ГОТОВА, ТЕПЕРЬ НУЖНО ПРИМЕНИТЬ ЭТУ СХЕМУ К МОДЕЛИ. 

59) Создаем константу Post, имя модели пишется с большой буквы, точно также как и имя конструктора. Присваиваем ей значение mongoose.model внутрь которого передаём 2 аргумента. Первый это имя модели, второй, это имя схемы, которую данная модель будет использовать.

//-----------------------Небольшое пояснение что и зачем-------------------------

Как было сказано ранее, mongoDB это база данных, которая хранит все данные. Напрямую работать с базой нельзя, так как в случае неправильной имплементации может произойти ситуация, когда хранящиеся данные будут разных форматов, разных структур с разными типами. Чтобы этого не произошло, используется дополнительная прослойка между сервером и базой данных. В нашем случае это mongoose. С помощью него мы во первых устанавливаем связь, а во вторых, используя разные модели, можем описать разные сущности, как например в нашем приложении, это данные постов и контактов. 
{
    Post model
    Contact model
} 
Модель - это обертка вокруг данных определенного типа, которая предоставляет удобные методы для работы с этими данными. По типу чтения всех или одного, изменения, поиска или удаления. Каждой из сущностей доступен этот набор.
{
    Post.find()
    Post.deleteOne()
    Post.findByld()

    Contact.get()
    Contact.find()
}
В свою очередь модель описывается с помощью схемы. Схема представляет собой набор полей у которых определены их типы и свойства.
Заключительным шагом экспортируем модель. Для этого используем метод exports, которой присваиваем значение созданой модели.
Переходим в файл сервера, куда импортируем только что созданную модель. Далее находим роут post, с помощью которого мы ранее добавляли данные и немного изменяем его логику. Оставим только деструктуризацию данных из запроса. Используя модель post, собираем новый обьект post. Внутрь конструктора передаём, получаемые в запросе данные. После чего использум простой метод .save. Он также является асинхронным, поэтому мы можем обработать приходящий результат. В then, используя метод res.send() отправляем данные на UI. То есть, если всё удачно сохранится, то мы увидим сохраненные данные в браузере. Ну а в catch мы перехватим ошибку и сделаем redirect на страницу ошибки.
//-----------------------Интеграция БД в проект----------------------------------

60) Далее мы рассмотрим ещё раз, работу с mongoDB и весь цикл создания модели.
    На данный момент, контакты хранятся непосредственно в файле сервера. У нас нету логику, для того, чтобы добавлять их в mongoDB через приложение, поэтому мы рассмотрим как это можно сделать через интерфейс сайта.
61) Для начала так как контакты это дополнительный тип данных, для них нужно создать новую коллекцию внутри базы данных webdev.
После создания, нажимаем и insert document и мы можем добавить пару ключи-значение. Добавляем name, link и их значения. Также делаем и для twitter. После того, как мы добавили, у нас есть 2 значения в нашей коллекции.
62) После того, как мы добавил данные в mongoDB, нам нужно создать для этих контактов модуль, поэтому мы переходим в нашу программу и в папке node-modules создаем файл contacts.js, куда копируем код из post.js. Схема будет называться contactSchema. В ней нам не нужен второй аргуемент timestamps, поскольку значения контактов мы не будем создавать в приложении, а будем брать их уже готовыми с базы данных. Убираем поле автора, а остальные заменяем на name и link. После чего називаем нашу модель Contact и задаём ей аналогичное имя. После этого экспортируем её из модуля. Теперь как логично предположить, импортируем её в файл сервера.
Супер, теперь база данных и файл сервера полностю готовы для дальнейшей работы. Ранее мы научились добавлять базу в mongoDB, но наш UI по прежнему использует информацию, которую он получает с файла сервера. Давайте обновим логику, чтобы все данные получать непосредственно с базы данных.
Ищем роут contacts и удаляем константу с контактами. После этого, обращаемся к модели contact и используем метод find(), Он помогает найти и вернуть все значения, которые находятся в коллекции. Метод find асинхронный, поэтому в then, мы можем отрендерить наш UI с полученными данными, а в случае ошибки, мы выведем ошибку в консоль и выведем страницу с ошибкой. Это всё, что нужно было внести в сервер, чтобы получать данные с mongoDB.
63) Теперь делаем анологично с роутом posts, который предназначен для отрисовки всех созданных новостей. Удаляем массив с данными, а логику можно скопировать прямо из Contact. Отлично, теперь мы и список новостей, получаем из БД.
64) Заключительный роут, который использует данных, хранящиеся на сервере, это роут отдельного поста. Здесь будет немного интересней, так как из базы нужно возвращать значение конкретного поста. Для этого мы будем использовать меод findByld(); Скопируем конструкцию Post и используем этот метод. Где он будет брать id. Ну очевидно, если вы посмотрите на роут, то увидите, что id будет храниться в адресной строке, а следовательно получить его можно из запроса, а конкретней из поля params, которое хранит различные параметры из адресной строки. После этого в метод then отправляется один пост и его мы отправляем в ответ. А в качастве страницы на UI, используем файл шаблон post.
Всё рабоет, но как мы можем заметить, не отображается дата на странице поста и на страницу со всеми постами. Если перейти в шаблон, то можно увидить, что мы используем старое поле date.
Давайте заменим его на cteatedAt в обоих ejs файлах (post, posts) и применим метод toLocalDateString для корректного отображения.
65) Далее давайте добавим новый пост на старницу и мы увидим, что нам выводт наш пост на страницу пользователя. Это та логика, которую мы добавили ранее, но давайте заменим её и сделаем по логике, чтобы при добавлении поста, пользователя перекидывало на страницу со всеми постами. Для этого просто метод send заменяем на redirect
66) Далее давайте сделаем небольшое улучшение и сделаем так, чтобы новый пост был вверху нашей страницы с постами, а не внизу. Для этого нам нужно выполнить сортировку по дате. Для этого мы ищем роут со список всех новостей и добавляем после метода find(), метод sort(), внутрь которого передаем обьект. В качестве ключа передаем поле, по которому будет производиться сортировка, а в качестве значения -1. То есть сортировать по убыванию.
67) Сейчас мы рассмотрим 2 последних типа запроса из стека крат операций. Сделали на странице с постами 1 доп. кнопку для удаления поста и на страницу с отдельным постом 2 кнопки, на удалиние и редактирование. Для того, чтобы иконки отлично отображались на строне UI, мы подключаем в head ссылку на fontawesom. 
Для начала начнём с удаления. Полностью реализовать удаление через сервер невозможно, так как с UI, нам нужно передавать данные. Удаление, которое мы реализуем, основывается на id элемента, поэтому изначально, нам нужно как то это поле пробросить из браузера.
Для начала немного изменив разметку в файле posts. На элемент кнопки, а также на элемент иконки, мы добавим data атрибут, который будет содержать тскомый id поста. Атрибут мы добавили на оба элемента и хоть это не красиво, зато практично. Для того, чтобы получить уникальный скрипт, мы будем использовать делегивароние и для того, чтобы не добавлять дополнительную логику по проверке типа элемента, мы просто дублировали id.
68) Добавляем тег скприт и внутри описываем следующую логику. На глобальный обьект document вешаем обработчик, который будет слушать все клики по документу. Метод не супер оптимальный, но зато может использоваться для обеих страниц с постами. Мы передаем событие и с помощью dataset проверяем есть ли этого элемента dataid. Потом проверяем и если есть, тогда вызываем fetch внутрь которого передаём в качесве первого аргумента url адрес, который будет обрабатывать запрос. В качетсве второго аргумента, мы передаём опции и в нашем случае это метод с типом delete. Теперь переходим в файл сервера и добавляем роут который будет обрабатывать удалиние.
Для этого копирум полностью роут posts/id
Метод findById заменяем на findByIdAndDelete. Then которые есть удаляем, а вместо него пишем callback функцию, которая будет отправлять статус код в браузер при удалении, либо выдавать ошибку и делать редирект на страницу с ошибкой. catch может быть такой же как и в других роутах. Всё, теперь технология удаления реализована, но проблема в том, что после каждого удаления, нужно перезагружать страницу, а так нехорошо, поэтому мы переходив в файл posts и так как fetch это асинхронный, мы можем добавить then а внутри конструкция window.location.reload(), что будет означать, что при успешном удалении, у нас дудет происходить успешаная перезагрузка страницы. Всё готово и теперь нам нужно сделать анологичную логику дла станицы деталей. Переходим в файл post и сначала изменяем разметк как и в предыдущем примере. Теперь нам нужна логика отправки данных на роут удаления. Как говорилось ранее, оптимальность написанного скрипта пошла в угоду его универсальности. (скрипт в файле posts). Поэтому мы спокойно копируем ранее созданный скрипт в файл post и лишь немного изменяем логику. При удалении поста со страницы с постом, мы будем делать редирект на страницу со всеми постами, так как нету смысла оставлять пользователя на странице несуществующего поста.
Супер, теперь наше приложение умеет удобавлять и удалять элементы, осталось научить его их редактировать. Для этого копируем файл add-post но меняем имя на edit-post. Фактически, можно было использовать и один, но для того, чтобы разграничить логику и не добавлять лишних проверок мы сделали дубликат. Что в этом шаблоне будет уникального? Ну для начала, он сможет принимать данные о редактируемой новости. Для этого, внутрь него мы будем передавть post и вытягивать из него заголовок, автора и текст. После чего присваивать эти значения в соответсвующие поля. Вторая отличительная особенность и наверное самая важная, это новое значение для атрибута action. Роут, который будет обрабатывать редактирование, начинается на edit, дальше в нём идет id редактируемого поста и финальный штрих, это определение типа метода. Так как говорилось ранее, для того, чтобы редактировать данные, используется метод PUT. Беда в том, что в html такого метода нету, поэтому метод формы у нас POST, а дополнительным флагом, мы указываем метод PUT, однако просто так, это всё тоже не заработает. Для того, чтобы отлавливать и реагировать на флаг, нам понадобится дополнительный модуль, который называется method-override. Скачиваем данный модуль с помощью npm install method-override и перезапускаем сервер и импортируем данный модуль в сам файл сервера. Данный пакет представляет собой middleware, поэтому его нужно подключить. Используем уже знакомую нам кострукцию app.use втутрь которой передаём данный модуль со строкой, на которую он будет реагировать. Тип такого подключения описан на страницу официальной документации, ну а про остальный варианты, можно почитать самостоятельно. 
Теперь нам нужно добавить 2 роута, почему 2? Потому, что мы создали страницу и первый роут должен возвращать эту страницу с формой, внутри которой заполнены все данные. Поэтому для начала мы используем метод get. Роут определяем как edit/id. Внутри задаём title = Edit Post, а логика возврата данных, точно такая же как и в роуте страницы одного поста, только вместо шаблона post, мы используем шаблон edit-post. Отлично, теперь на эту страницу нам нужно как то попадать. Для этого в файле post, кнопку редактирования, мы заменяем на ссылку и добавляем href = edit с параметром id. Теперь нужно добавить логику, чтобы вносимые изминения, обновляли существующий в базе пост. Для этого возвращаемся в файл сервера и создаём новый роут с методом put. Точно также как и при создании нового поста, мы будем получать данные о заголовке, авторе и тексте из тела запроса. После чего нужно не сохранить новый пост, а обновить сущствующий. Для этого нужно у модели пост, вызвать метод findByIdAndUpdate. Данный метод, ищет в базе элемент по определенному id, после чего обновляет его поля новыми полученными данными, поэтому в качестве аргументов, он принимает id, который мы таки берем из параметров запроса, а в качестве второго аргумента, идёт обьект с данными. Ну и в случае успешного обновления, нам нужно выполнить переход на страницу деталей. В случае же ошибки, отрисовать страницу ошибки.
69) Теперь мы сделаем небольшой рефакторинг нашего приложения. За последнее время мы сделали неплохое приложения используя весь список крат операций, но проблема в том, что логику всего сервера мы описываем в одном файле. И хоть функциональность описанная в сервере очень не маленькая, но при дальнейшом расширении, может получится очень большой и запутанный файл сервера, где вся бизнес-логика свалена в кучу. В результате дальнейшая поддержка, может привести к проблемам. Поэтому сейчас мы сделаем рефакторинг нашего приложения, отделим бизнеслогику и организуем её в соответсвии с патерном MVC, а также отделим логику, которая отвечает за роутинг в приложении.
70) В первую очередь отделяем логику роутинга, так как эта самая большая часть кода на нашем сервере и с добавлением новых страниц, это часть кода будет только увеличиваться. Для этого создадим папку в папке нашего проекта routes и внутри этой папки создадим файл post-routes. Внутрь этого файла перенесем все роуты, которые связанные с постами - добавление, удаление, изменения. В данный момент все роуты обращаются к приложению app, но само приложение определено в файле сервера. Поэтому внутри файла post-routes, нам нужно создать своё мини приложение, которое будет работать с роутами. Поэтому для начала нам нужно экспортировать Экспресс в этот файл. Затем создать экземпляр роутера. Для этого в экспресс есть специальный коснтруктор, который так и называется Router(). Теперь, когда у нас есть экземпляр роутера, то по всем запросам, мы можем обращаться к нему. Заменяем во всех app. на router. И теперь как логично предположить, созданный экземпляр роутера, нам нужно использовать в файле сервера. Поскольку на данный момент, мы просто получили отдельный файл с инкапсулированным куском логики. Для начала, превратим этот файл в модуль из которого экспортируем сущность router. После этого, импортируем router из постов в наш файл сервера. Теперь на сервере есть доступ к мини приложению с логикой сущности post. Модель Post, после того, как мы перенесли логику в отдельный файл, перестала использоваться на сервере, а в post-routes она как раз таки нужна, поэтому можем вырезать её и перенести в файл post-routes. Только нужно изменить путь, так как мы находимя не в корне проэкта. 
Прежде чем что то подключать, давайте аналогичным образом поступим и с роутом контактов. Подключаем экспресс, создаем роутер, заменяем app на router, экспортируем router и импортируем этот модуль в файл сервера. Так как этот роут один этого можно было и не делать, но так как мы понимаем, что возможно в будущем будет заложена логика, которая будет позволять менять или добавлять контакты, то мы заранее делаем роуты связанные с контактами в отдельном файле. Отлично, теперь логика, отвечающая за работу с новостями(постами) и контактами отделена. 
Теперь эти подключенные роуты, нам нужно добавить в приложение. Делается это очень просто, по аналогии к подключению обычного middleware. Используем конструкцию app.use(postRoutes) внутрь которой передаём роут. Далее нам нужна папка helpers, внутри которой мы создаём файл create-path.js. Нвутрь файла импортируем модуль path и вырезаем из файла сервера функцию createPath в файл create-path.js.
Давайте теперь обновим немного её логику. Поскольку мы теперь идём не от корня проекта, нам нужно поменять путь к ejs файлам на уровень выше. Заключительным шагом экспортируем эту функцию из модуля. Всё дело в том, что данная фукнция, используется в 3 файлах. 2 модуля роутов и модуль сервера. После того, как все модули разделены и все импорты тоже произведены. Только что мы отделили логику роутинга от логики сервера. Теперь дополнительно, функциональность отвечающую за работу с модулями, мы можем вынести из роута. За основу мы возьмем патерн MVC или modelViewController. 
Даный паттерн позволяет разбить монолитное приложение на независимые сформированные структуры. Каждый из которых отвечает за свою конкреткую логику. Это помогает держать код модульно, увеличить его переиспользуемость, читаемость и поддерживаемость.
MODEL - это сущность, описывающая структуру данных, которые используются в приложении.
{
    post.js
    contact.js
}
VIEW - это интерфейс, который предназначен для рендеринга получаемых данных и работы с ними, по сути это UI.
{
    post.ejs
    contact.ejs
    index.ejs
    error.ejs
}
CONTROLLS THE APP - это логика в которой и и используются предоставляемые методы. Он содержит бизнес логику и служит посредником между моделью и интерфейсом.
{
    post-controller.js
    contact-controller.js
}
В нашем приложении мы уже заложили основу этого паттерна, это папка models, в которой мы храним модели сущностей с которыми мы работаем в приложении и у нас есть папка views, кстате давайте её переименуем и заменим данные в хелпере. Так вот - views содержит ejs шаблоны, в которые мы пробрасываем данные и рендерим их, а вот логика контроллера у нас находится в роутах и это не совсем верно, поэтому следующим шагом рефакторинга будет отделения контроллера от роутера. Создаем папку controllers и файл post-controller.js. Внутрь него можна сразу перенести сразу модель Post и хелпер createPath, больше в роутере, они не нужны. Создаём контроллер getPost, принимать он будет запрос и ответ, то есть те аргументы, которые у нас используются в роутере. После чего вырезаем всю логику из роута и вставляем её в контроллер. Следующим шагом экспортируем контроллер. На этот раз мы воспользуемся обьектом экспорта, так как контроллеров будет несколько. Потом возвращаемся в файл post-routes и использую деструктуризацию импортируем контроллер. После чего добавляем его на роут, где мы вырезали функцию. Делаем аналогично со всеми роутами и в файле post-routes contact-routes.
Дальше мы импортируем нужные контроллеры в файд роута и используем. Теперь если нам нужно внести изменения и нужно обновить контроллер или его заменить, то файл роута или не изменяется вообще, либо вносятся минимальные изменения на нужный контроллер. Всё легко читается и расширается. Даже если появится 10 новых роутов, файл по прежнему останется поддерживаемым.
Теперь косательно файла контроллера. Он содержит набор функций, где границы каждой легко найти. Если изменяется бизнес логика или используемая модель, то вносимые изменения будут опять таки минимальны. Внутри фукнции определена модель, с которой происходит взаимодействие, а также логика по возврату нужного компонента пользователю и обработка ошибок. Последний пункт, я бы тоже улучшил, чтобы не нарушать принцип don't repeat yourself. Поскольку перехват ошибки, это повторяющаяся логика, то есть вивод ошибки в консоль и рендер страницы ошибки. Мы можем вынести её в отдельную функцию. Назовём её handleError. 
Теперь у нас в файле сервера осталось только подключение к БД, определение middleware и роутинг. Основная же логика сервера разбира с помощью MVC паттерна, 


//--------------------СОЗДАНИЕ API----------------------------
71) API - Aplication Programming Inteface - это программный интерфейс приложения и если говорть проще, это набор url адресов со своими методами, которые позволяют манипулировать данными. По сути это составляющая часть сервера, которая получает запросы и отправляет ответы. Перед этим мы сделали приложение, которое работает с новостями, оно может читать их, добавлять, редактировать, удалять, но проблема в том, что вся логика крат операций завязана на интерфейс. А это значит, что для того, чтобы точно такую же логику интегрировать в другой шаблонизатор или даже в js framework, мне придется изменять файлы сервера под новый viewEngine. Намного проще будет создать API, где с помощью url адреса и типа запроса, мы можем взаимодействовать с данными. Сейчас мы поймем насколько правильным было отделение контроллеров. Копируем файл post-routes и меняем имя на api-post-routes. Внутри нам понадобится только 5 роутов. Это роут получения всех запросов. Единственным изменением в пути, поскольку мы работает с API и будет добавление этой строки в адрес.
Чтобы отделить роуты, которые предназначены для интерфейса, от роутов, которые нужны для програмного взаимодействия. Слудующий роут, это добавления нового поста. Чтобы сохранить общую консистентность работы с данными, его путь я также изменю с app post с api post. Ключевой момент, это именно метод, который используется. Дальше нам нужен роут, чтобы получить доступ к конкретной новости. Изменяем пока мы только пути, исользуемые контроллеры пока не трогаем. Следующая операция, это удаление новости по ID. И заключительный роут, это роут изменения значения определенного поста. Таким образом у нас поддерживается логика возврата одно и нескольких постов, а также возможности манипуляций с определенной новостью. Теперь, лишние контроллеры, мы можем удалить. Тем более, что они уже подсветились как неиспользуемые. Вроде как пол дела сделано, поэтому можем переходить в папку с контроллерами и создаём копию файла post-controller и вот здесь нам придется немного порефакторить. Для начала, по скольку мы больше не зависим от интерфейса, мы можем удалить утилиту createPath и все её использования. Удаляем все then внутри везде. Основная идея в создании API, это то, что вместо разметки или ещё каких нибудь элементов интерфейса, будут возвращаться данные только в JSON формате. Эти данные мы сможем использовать в абсолютно любом приложении. Теперь нам нужно оставить только те функции, которые мы используем в роуте API, остальные удаляем и не забываем удалить из экспорта. Следующий шаг это удаление константы title в кажом контроллере. Она также не нужна, так как используется для интерфейса. Заметьте, основную логику контроллера по взаимодействию с моделью, мы не трогали. А вто теперь, мы можем заполнить наш метод then. Как говорилось ранее, работа идет только с данными, поэтому во всех случаях мы будем возвращать json, который будет содержать 3 типа данных. Первый это все посты для роута с возвратом всех значений. Второй, это один пост, для варианта просмотра, добавления и редактирования. Третий, это значение ID в случае, если пост мы удаляем. Все отеты, мы дополнительно расширим двухсотым статус кодом, то есть сообщим о том, что запрос произошел успешно. Заключительный шаг, это небольшое изменение функции handleError. В случае любой ошибки, мы будем возвращать 500 статус код и отправлять информацию об ошибке. Ну что ж, наш контроллер полностью готов и готов к использованию, поэтому в файле api-post-routes изменяем используемый контроллер на api-post-controller. Переходим в файл сервера и для начала импортируем созданный файл для api роутинга. Далее с помощью app.use включаем его в наше приложение. 
Если мы перейдем в интрнет и попробуем переходить между страницами нашего приложения то увидим, что оно работает, но если мы в url поле добавим api/posts, например, то вместо разметки, получим возвращаемые с mongoDB данные и вот эти данные, мы инкапсулированно можем использовать где угодно. Теперь нам нужно убедиться, что все созданные пути отрабатывают корректно. Нужно понимать, что разработка интерфейса и сервера идёт параллельно и не всегда UI будет готов для того, чтобы протестировать backend. Поэтому в качестве тестировочного софта, мы воспользуемся POSTMAN. Оно позволяет конфигурировать и создавать любые запросы и тестировать backend или API приложения.
